import { GoogleGenerativeAI, type GenerativeModel } from '@google/generative-ai';
import { db } from '../config/db';
import { GEMINI_API_KEY } from '../config/env';
import {
  snapshots,
  incidents,
  timelineEvents,
  type Snapshot,
  type TimelineEvent,
  type InsertTimelineEvent,
} from '../models';
import { eq, desc, inArray } from 'drizzle-orm';
import { sseManager } from './sse';

// Initialize Gemini
const genAI = new GoogleGenerativeAI(GEMINI_API_KEY);
const model: GenerativeModel = genAI.getGenerativeModel({ model: 'gemini-2.5-flash' });

/**
 * Number of recent snapshots to include as context for the AI
 */
const CONTEXT_SNAPSHOT_COUNT = 10;

/**
 * Schema for timeline events generated by AI
 */
interface AITimelineEvent {
  timestamp: string; // ISO timestamp
  description: string;
  fromState?: Record<string, unknown>;
  toState?: Record<string, unknown>;
  confidence: number;
  sourceSnapshotIndices: number[]; // Indices into the snapshots array
}

interface AIResponse {
  events: AITimelineEvent[];
  updatedState?: Record<string, unknown>;
}

/**
 * Build the prompt for Gemini to analyze snapshots and generate timeline events
 */
function buildPrompt(
  newSnapshots: Snapshot[],
  contextSnapshots: Snapshot[],
  currentState: Record<string, unknown> | null
): string {
  const contextSection = contextSnapshots.length > 0
    ? `## Recent Context (Previous Snapshots)
${contextSnapshots.map((s, i) => `[${i}] ${s.timestamp.toISOString()}: ${s.scenario} - ${JSON.stringify(s.data)}`).join('\n')}

`
    : '';

  const currentStateSection = currentState
    ? `## Current Incident State
${JSON.stringify(currentState, null, 2)}

`
    : '';

  const newSnapshotsSection = `## New Snapshots to Analyze
${newSnapshots.map((s, i) => `[${i}] ${s.timestamp.toISOString()}: ${s.scenario} - ${JSON.stringify(s.data)}`).join('\n')}
`;

  return `You are an AI agent analyzing video surveillance snapshots to build a timeline of an incident. Your job is to identify meaningful STATE CHANGES, not just describe states.

${currentStateSection}${contextSection}${newSnapshotsSection}

## Your Task
Analyze the new snapshots and identify any meaningful CHANGES or TRANSITIONS that occurred. Focus on:
- Movement/position changes (entered, exited, moved to)
- Status changes (started, stopped, picked up, dropped)
- New entities appearing or disappearing
- Significant actions or events

DO NOT report static states. Only report when something CHANGES from one state to another.

## Response Format
Respond with a JSON object containing:
1. "events": Array of timeline events (can be empty if no meaningful changes detected)
2. "updatedState": Updated understanding of the current incident state (optional)

Each event should have:
- "timestamp": The ISO timestamp when the change occurred (use the snapshot timestamp)
- "description": A clear, human-readable description of what changed
- "fromState": The previous state (optional)
- "toState": The new state (optional)
- "confidence": A number from 0 to 1 indicating confidence
- "sourceSnapshotIndices": Array of indices from the new snapshots that support this event

Example response:
{
  "events": [
    {
      "timestamp": "2024-01-15T14:30:05.000Z",
      "description": "Man enters building through main entrance",
      "fromState": {"location": "outside", "action": "walking"},
      "toState": {"location": "inside_building", "action": "standing"},
      "confidence": 0.9,
      "sourceSnapshotIndices": [1]
    }
  ],
  "updatedState": {
    "persons": [{"location": "inside_building", "description": "adult male"}],
    "threatLevel": "low"
  }
}

Respond ONLY with the JSON object, no additional text.`;
}

/**
 * Parse the AI response into timeline events
 */
function parseAIResponse(responseText: string, newSnapshots: Snapshot[]): AIResponse {
  try {
    // Clean up potential markdown code blocks
    let cleaned = responseText.trim();
    if (cleaned.startsWith('```json')) {
      cleaned = cleaned.slice(7);
    }
    if (cleaned.startsWith('```')) {
      cleaned = cleaned.slice(3);
    }
    if (cleaned.endsWith('```')) {
      cleaned = cleaned.slice(0, -3);
    }
    cleaned = cleaned.trim();

    const parsed = JSON.parse(cleaned) as AIResponse;
    return {
      events: parsed.events || [],
      updatedState: parsed.updatedState,
    };
  } catch (error) {
    console.error('Failed to parse AI response:', error);
    console.error('Raw response:', responseText);
    return { events: [] };
  }
}

/**
 * Get recent snapshots for context
 */
async function getRecentContext(incidentId: string): Promise<Snapshot[]> {
  const recentSnapshots = await db
    .select()
    .from(snapshots)
    .where(eq(snapshots.incidentId, incidentId))
    .orderBy(desc(snapshots.timestamp))
    .limit(CONTEXT_SNAPSHOT_COUNT);

  // Return in chronological order
  return recentSnapshots.reverse();
}

/**
 * Get the current incident state
 */
async function getIncidentState(incidentId: string): Promise<Record<string, unknown> | null> {
  const [incident] = await db
    .select({ currentState: incidents.currentState })
    .from(incidents)
    .where(eq(incidents.id, incidentId));

  return incident?.currentState as Record<string, unknown> | null;
}

/**
 * Store timeline events in the database
 */
async function storeTimelineEvents(
  videoId: string,
  events: AITimelineEvent[],
  newSnapshots: Snapshot[]
): Promise<TimelineEvent[]> {
  if (events.length === 0) {
    return [];
  }

  const insertValues: InsertTimelineEvent[] = events.map((event) => ({
    videoId,
    timestamp: new Date(event.timestamp),
    description: event.description,
    fromState: event.fromState ?? null,
    toState: event.toState ?? null,
    confidence: event.confidence,
    sourceSnapshots: event.sourceSnapshotIndices.map((i) => newSnapshots[i]?.id).filter(Boolean),
  }));

  const inserted = await db.insert(timelineEvents).values(insertValues).returning();
  return inserted;
}

/**
 * Update the incident's current state
 */
async function updateIncidentState(
  incidentId: string,
  newState: Record<string, unknown>
): Promise<void> {
  await db
    .update(incidents)
    .set({
      currentState: newState,
      updatedAt: new Date(),
    })
    .where(eq(incidents.id, incidentId));
}

/**
 * Main function to generate timeline events from a batch of snapshots
 * This is called by the snapshot buffer when it flushes
 */
export async function generateTimelineEvents(
  incidentId: string,
  newSnapshots: Snapshot[]
): Promise<TimelineEvent[]> {
  if (newSnapshots.length === 0) {
    return [];
  }

  // Get videoId from the first snapshot (all snapshots in batch are from same video)
  const videoId = newSnapshots[0].videoId;

  console.log(`Generating timeline events for video ${videoId} (incident ${incidentId}) from ${newSnapshots.length} snapshots`);

  try {
    // Get context
    const contextSnapshots = await getRecentContext(incidentId);
    const currentState = await getIncidentState(incidentId);

    console.log(`Context: ${contextSnapshots.length} recent snapshots, current state: ${currentState ? 'exists' : 'none'}`);

    // Build prompt and call Gemini
    const prompt = buildPrompt(newSnapshots, contextSnapshots, currentState);
    console.log(`Calling Gemini with ${newSnapshots.length} new snapshots...`);
    
    const result = await model.generateContent(prompt);
    const responseText = result.response.text();

    console.log(`Gemini response:\n${responseText.slice(0, 500)}${responseText.length > 500 ? '...' : ''}`);

    // Parse response
    const aiResponse = parseAIResponse(responseText, newSnapshots);
    console.log(`Parsed ${aiResponse.events.length} events from Gemini response`);

    // Store events with videoId
    const storedEvents = await storeTimelineEvents(videoId, aiResponse.events, newSnapshots);

    // Update incident state if provided
    if (aiResponse.updatedState) {
      await updateIncidentState(incidentId, aiResponse.updatedState);

      // Broadcast state update via SSE
      sseManager.broadcastToIncident(incidentId, 'stateUpdated', {
        incidentId,
        state: aiResponse.updatedState,
        timestamp: new Date().toISOString(),
      });
    }

    // Broadcast each timeline event via SSE
    for (const event of storedEvents) {
      sseManager.broadcastToIncident(incidentId, 'timelineEvent', {
        videoId,
        event,
        timestamp: new Date().toISOString(),
      });
    }

    console.log(`Generated ${storedEvents.length} timeline events for video ${videoId}`);
    return storedEvents;
  } catch (error) {
    console.error(`Error generating timeline events for video ${videoId}:`, error);
    throw error;
  }
}

/**
 * Batch processor callback for the snapshot buffer
 */
export async function processBatch(incidentId: string, snapshotBatch: Snapshot[]): Promise<void> {
  await generateTimelineEvents(incidentId, snapshotBatch);
}
